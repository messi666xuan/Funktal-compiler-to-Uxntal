( state constants )
%Base { #00 }
%Identifier { #05 }
%TypeIdentifier { #06 }
%Constant { #07 }
%TypeSeparator { #08 }
%Assignment { #09 }
%Operator { #0a }
%ParenOpen { #0b }
%ParenClose { #0c }
%BindOpen { #0d }
%BindClose { #0e }
%AltSeparator { #0f }
%NumConst { #10 }
%CharConst { #11 }
%EndCharConst { #12 }
%StringConst { #13 }
%EndStringConst { #14 }
%Separator { #15 }
%TypeDeclarator { #16 }
%BlockOpen { #17 }
%BlockClose { #18 }
%TypeParenOpen { #19 }
%TypeParenClose { #1a }
%BracketOpen { #1a }
%BracketClose { #1b }
%Minus { #1c }
%Operator2 { #1d }
%Error { #1e }
%Skip { #1f }
%Comment { #20 }
%ExprSeparator { #21 }
%Comma { #22 }
%Quote { #23 }
%LeftPointy { #24 }

( context )
%None { #00 }
%Libraries { #01 }
%Uxntal { #02 }
%Aliases { #03 }
%Types { #04 }
%Constants { #05 }
%ProgramState { #06 }
%Devices { #07 }
%Functions { #08 }
%Main { #09 }

( token labels )
%ContextLabel { #01 }
%IdentifierLabel { #02 }
%TypeIdentifierLabel { #03 }
%EmbeddedConstantLabel { #04 }
%ConstantLabel { #05 }
%SeparatorLabel { #06 }
%OperatorLabel { #07 }
%TypeSynonymLabel { #08 }
%ArgLabel { #09 }
%FNameLabel { #0a }
%PatternLabel { #0b }
%EndBindLabel { #0c }
%NamedConstantLabel { #0d }
%StateVarLabel { #0e }
%DeviceLabel { #0f }

( Const labels ( 2 bits ) )
%CString { #01 }

|0000
|10 @Console &vector $2 &read $1 &pad $5 &write $1 &error $1
@state $1 @c $1 @prevc $1
@nextState $1 @prevState $1
@context $1 @prevContext $1 @funktalToken $2
@idId $1 @stringConstIdx $1 @numConstIdx $1 @charIdx $1
@constId $1 @taggedConstId $2 @numConstId $1 @inBlock $1
@strLen $2 @funktalIdentifier $10 @hasMain $1
@funktalIdentifierStringsIdx $1  
@index $1 @label $2 @funktalTokensIdx $1


|0100
 
( this is the main program. Here is where you call the function )
BRK





@isTypeIdentifierStartChar
    .c LDZ #40 GTH
    .c LDZ #5b LTH
    AND
JMP2r

@isIdentifierStartChar
    .c LDZ #60 GTH
    .c LDZ #7b LTH
    AND
    .c LDZ #5f EQU
    ORA
JMP2r

@isDigit
    .c LDZ #2f GTH
    .c LDZ #3a LTH
    AND
JMP2r

@isOperator
    .c LDZ #29 GTH
    .c LDZ #30 LTH
    AND
    .c LDZ #21 EQU
    .c LDZ #25 EQU
    ORA ORA         ( (ic >= 42 .and. ic <= 47) .or. ic == 33 .or. ic == 37 )
    .c LDZ #26 EQU
    .c LDZ #3c EQU
    ORA
    .c LDZ #3d EQU
    .c LDZ #3e EQU
    ORA ORA         ( ic == 38 .or. ic == 60 .or. ic == 61 .or. ic == 62 )
    .c LDZ #5e EQU
    .c LDZ #7c EQU
    ORA
    .c LDZ #7e EQU
    ORA ( ic == 94 .or. ic == 124 .or. ic == 126 )
    ORA ORA
JMP2r

@isExprSeparator
    .c LDZ #0a EQU
    .c LDZ LIT "; EQU
    ORA
JMP2r

@numConstant $8 @stringConstant $80 
@funktalIdentifierStringIdxs $300

@funktalIdentifier_achar0
    #00 .Index STZ
    #10 ( counter=16 )
    #00 .funktalIdentifier STZ ( Set current byte to 0 )
    &loop
        #01 SUB  ( Decrement loop counter )
        .Index LDZ INC .Index STZ
        #00 .Index LDZ .funktalIdentifier ADD STZ  ( Move to next byte in the array )
        
        DUP
        #00 NEQ ,&loop JCN ( If loop counter is not zero, jump back to &loop )

JMP2r  ( Return to the main program )

@numConstant_achar0
    #00 .Index STZ
    #08 ( counter=8 )
    #00 ;numConstant STA ( Set current byte to 0 )
    &loop
        #01 SUB  ( Decrement loop counter )
        .Index LDZ INC .Index STZ
        #00 .Index LDZ ;numConstant ADD STA  ( Move to next byte in the array )
        
        DUP
        #00 NEQ ,&loop JCN ( If loop counter is not zero, jump back to &loop )

JMP2r  ( Return to the main program )

@stringConstant_achar0
    #00 .Index STZ
    #80 ( counter=128 )
    #00 ;stringConstant STA ( Set current byte to 0 )
    &loop
        #01 SUB  ( Decrement loop counter )
        .Index LDZ INC .Index STZ
        #00 .Index LDZ ;stringConstant ADD STA  ( Move to next byte in the array )
        
        DUP
        #00 NEQ ,&loop JCN ( If loop counter is not zero, jump back to &loop )

JMP2r  ( Return to the main program )

@tokeniseFunktal
    .state LDZ .nextState STZ
    ;updateState JSR2
    .state LDZ Comment NEQ
    ;tokeniseFunktal_not_Comment JCN2

@tokeniseFunktal_not_Comment
    ;updateContext JSR2
    .context LDZ None EQU
    ;context_None1 JCN2
    .state LDZ Identifier EQU
    ;tokeniseFunktal_Identifier JCN2
    .state LDZ TypeIdentifier EQU
    ;tokeniseFunktal_TypeIdentifier JCN2
    .state LDZ NumConst EQU
    ;tokeniseFunktal_NumConst JCN2
    .state LDZ StringConst EQU
    ;tokeniseFunktal_StringConst JCN2
    .state LDZ EndStringConst EQU
    ;tokeniseFunktal_EndStringConst JCN2
    isSeparator

JMP2r

@context_None1
    #00 .inBlock STZ

@tokeniseFunktal_Identifier ( if (state == Identifier) )
    .prevState LDZ Identifier NEQ
    ,&prevState_not_Identifier JCN
    ,&prevState_Identifier JMP

    &prevState_not_Identifier  ( if (prevState /= Identifier) )
        ;funktalIdentifier_achar0 JSR2 ( funktalIdentifier=achar(0) )
    
        .prevState LDZ NumConst NEQ
        ,&prevState_not_NumConst JCN
        
        .prevc LDZ #00 EQU .c LDZ LIT "x EQU ( prevc=='0' .and. c =='x' )
        AND
        ,&prevc0_cx JCN

    &prevState_Identifier
        .c LDZ .charIdx LDZ .funktalIdentifier ADD STZ ( funktalIdentifier(charIdx) = c )
        .charIdx LDZ INC .charIdx STZ

    &prevState_not_NumConst  ( if (prevState /= NumConst) )
        .c LDZ .funktalIdentifier STZ
        #02 .charIdx STZ

    &prevc0_cx   ( else if(prevc=='0' .and. c =='x') )
        .prevc LDZ .funktalIdentifier STZ
        .c LDZ .funktalIdentifier #01 ADD STZ
        #03 .charIdx STZ

@tokeniseFunktal_TypeIdentifier         ( if (state == TypeIdentifier) )
    .prevState LDZ TypeIdentifier NEQ
    ,&prevState_not_TypeIdentifier JCN
    ,&prevState_TypeIdentifier JCN

    &prevState_not_TypeIdentifier
        ;funktalIdentifier_achar0 JSR2        ( funktalIdentifier=achar(0) )
        .c LDZ .funktalIdentifier STZ
        #02 .charIdx STZ

    &prevState_TypeIdentifier
        .c LDZ .charIdx LDZ .funktalIdentifier ADD STZ      ( funktalIdentifier(charIdx) = c )
        .charIdx LDZ INC .charIdx STZ

@tokeniseFunktal_NumConst          ( if (state == NumConst) )
    .prevState LDZ NumConst NEQ
    ,&prevState_not_NumConst JCN
    ,&prevState_NumConst JMP

    &prevState_not_NumConst
        ;numConstant_achar0 JSR2   ( numConstant = achar(0) )
        .state LDZ Minus EQU
        ,&prevState_Minus JCN
        ,&prevState_not_Minus JMP
    JMP2r

    &prevState_NumConst
        .c LDZ .constId LDZ ;numConstant ADD STA
        .constId LDZ INC .constId STZ
    JMP2r

    &prevState_Minus
        LIT "- ;numConstant STA
        .c LDZ #01 ;numConstant ADD STA
        #03 .constId STZ
    JMP2r

    &prevState_not_Minus
        .c LDZ ;numConstant STA
        #02 .constId STZ
    JMP2r

@tokeniseFunktal_StringConst          ( if (state == StringConst) )
    .prevState LDZ StringConst NEQ
    ,&prevState_not_StringConst JCN
    ,&prevState_StringConst JMP

    &prevState_not_StringConst
        ;stringConstant_achar0 JSR2   ( stringConstant = achar(0) )
        #01 .constId STZ
    JMP2r

    &prevState_StringConst
        .c LDZ .constId LDZ ;stringConstant ADD STA
        .constId LDZ INC .constId STZ
    JMP2r

@funktalTokens $800
@tokeniseFunktal_EndStringConst          ( if (state == EndStringConst) )
    ( call addStringConstIfNew(stringConstant,constId,funktalStringConstsIdx,funktalStringConstId, idId) )
    CString #40 SFT ( ishft(CString,4) )
    ConstantLabel ADD .taggedConstId STZ2
    .taggedConstId LDZ2 .label STZ2
    ;makeFunktalToken JSR2
    ;token LDA2 .funktalToken STZ2
    .funktalToken LDZ2 .funktalTokensIdx LDZ ;funktalTokens ADD STA2
    .funktalTokensIdx LDZ INC .funktalTokensIdx STZ
JMP2r

@token $2
@makeFunktalToken
    .label LDZ2 #a0 SFT
    .idId LDZ2 #03ff AND
    ADD2 ;token STA2
JMP2r

@encodeOperatorToken
    .c LDZ LIT "+ EQU


@identifierType $1 @tidentifierStringIdx $2 @tidentifierStringId 2
@idIdx $1 @j $1 @k $1 @cc $1 @ccc $1 @newStringConst $1 
@funktalTypeIdentifierStringIdxs $100 @funktalTypeIdentifierStringLengths $100 @funktalTypeIdentifierStrings $800
@funktalIdentifierStringLengths $300 @funktalIdentifierStrings $800
@addIdentifierIfNew 
    #01 ;j STA 
    #01 ;k STA
    ;addIdentifierIfNew_loopj JSR2
    #01 newStringConst STA

@addIdentifierIfNew_loopj
    #00 newStringConst STA
    ;identifierType LDA #01 EQU
    ;identifierType_1j JCN2
    ;addIdentifierIfNew_loopk JSR2
    ;j LDA .idId STZ
    ;addIdentifierIfNew_222 JSR2

    
JMP2r


@identifierType_1j
    ;funktalTypeIdentifierStringIdxs ;j LDA ADD LDA 
    ;idIdx STA
    ;funktalTypeIdentifierStringLengths ;j LDA ADD LDA
    .charIdx LDZ #01 SUB NEQ
    ;addIdentifierIfNew_111 JCN2
    ;funktalIdentifierStringIdxs ;j LDA ADD LDA
    ;idIdx STA
    ;funktalIdentifierStringLengths ;j LDA ADD LDA
    .charIdx LDZ #01 SUB NEQ
    ;addIdentifierIfNew_111 JCN2



@addIdentifierIfNew_loopk
    ;identifierType LDA #01 EQU
    ;identifierType_1k JCN2
    ;identifierType_1k_else JSR2
    ;addIdentifierIfNew_loopk_endif JSR2
    ;k LDA INC DUP ;k STA
    .charIdx LDZ #01 SUB NEQ
    ;addIdentifierIfNew_loopk JCN2

@addIdentifierIfNew_loopk_endif
    .funktalIdentifier ;k LDA ADD LDZ ;ccc LDA
    ;cc LDA ;ccc LDA NEQ
    ;addIdentifierIfNew_111 JCN2
JMP2r

@identifierType_1k
    ;idIdx LDA ;k LDA ADD #01 SUB ( idIdx+k-1 )
    ;funktalTypeIdentifierStrings ADD LDA .cc STA  ( cc =  funktalTypeIdentifierStrings(idIdx+k-1) )


@identifierType_1k_else
    ;idIdx LDA ;k LDA ADD #01 SUB ( idIdx+k-1 )
    ;funktalIdentifierStrings ADD LDA .cc STA

@addIdentifierIfNew_111
    ;j LDA INC DUP ;j STA
    ;tidentifierStringId LDA NEQ
    ;addIdentifierIfNew_loopj JCN2
    ;addIdentifierIfNew_loopj JSR2

@addIdentifierIfNew_222
    ;newIdentifier LDA
    ;newIdentifier_true JCN2
JMP2r

@newIdentifier_true 
    ;tidentifierStringId LDA .idId STZ
    ;identifierType_if JSR2
    #01 ;k STA
    ;addIdentifierIfNew_222_loopk JSR2
    ;tidentifierStringId LDA INC ;tidentifierStringId STA

    ;identifierType_222_end_judge JSR2
    ;tidentifierStringId LDA INC ;tidentifierStringId STA
    .charIdx LDZ #01 SUB
    ;tidentifierStringIdx LDA ADD ;tidentifierStringIdx STA

JMP2r
@identifierType_if
    ;identifierType LDA #01 EQU
    ;identifierType_222_1 JCN2
    ;identifierType_222_not_1 JSR2
JMP2r
@identifierType_222_1
    ;tidentifierStringIdx LDA ;funktalTypeIdentifierStringIdxs .idId LDZ ADD LDA
JMP2r

@identifierType_222_not_1
    ;tidentifierStringIdx LDA ;funktalIdentifierStringIdxs .idId LDZ ADD LDA
JMP2r

@addIdentifierIfNew_222_loopk
    ;identifierType LDA #01 EQU
    ;identifierType_222_1k JCN2
    ;identifierType_222_not_1k JSR2
JMP2r
@identifierType_222_1k
    .funktalIdentifier ;k LDA ADD LDZ
    ;funktalTypeIdentifierStrings ;tidentifierStringIdx LDA ;k LDA ADD #01 SUB ADD2 LDA
JMP2r

@identifierType_222_not_1k
    .funktalIdentifier ;k LDA ADD LDZ
    ;funktalIdentifierStrings ;tidentifierStringIdx LDA ;k LDA ADD #01 SUB ADD2 LDA
JMP2r
@identifierType_222_end_judge
    ;identifierType LDA #01 EQU
    ;identifierType_222_end_judge_1 JCN2
    ;identifierType_222_end_judge_not_1 JSR2
JMP2r
@identifierType_222_end_judge_1
    .charIdx LDZ #01 SUB
    ;funktalTypeIdentifierStringLengths .idId LDA ADD STA
JMP2r
@identifierType_222_end_judge_not_1
    .charIdx LDZ #01 SUB
    ;funktalIdentifierStringLengths .idId LDA ADD STA
JMP2r

@updateContext
    .context LDZ None EQU
    ,&context_None JCN
JMP2r  

    &context_None
        .state LDZ BlockOpen EQU
        ,&state_BlockOpen JCN

        .state LDZ BlockClose EQU
        ,&state_BlockClose JCN
    JMP2r

    &state_BlockOpen
        .funktalIdentifier #00 LDZ ADD LDZ
        LIT "l EQU
        ,&Libraries JCN
        .funktalIdentifier #00 LDZ ADD LDZ
        LIT "u EQU
        ,&Uxntal JCN
        .funktalIdentifier #00 LDZ ADD LDZ
        LIT "t EQU
        ,&Types JCN
        .funktalIdentifier #00 LDZ ADD LDZ
        LIT "a EQU
        ,&Aliases JCN
        .funktalIdentifier #00 LDZ ADD LDZ
        LIT "c EQU
        ,&Constants JCN
        .funktalIdentifier #00 LDZ ADD LDZ
        LIT "s EQU
        ,&ProgramState JCN
        .funktalIdentifier #00 LDZ ADD LDZ
        LIT "d EQU
        ,&Devices JCN
        .funktalIdentifier #00 LDZ ADD LDZ
        LIT "f EQU
        ,&Functions JCN
        .funktalIdentifier #00 LDZ ADD LDZ
        LIT "m EQU
        ,&Main JCN

        .context LDZ .prevContext STZ
        ;funktalIdentifier_achar0 JSR2 ( funktalIdentifier=achar(0) )
    JMP2r
    
    &state_BlockClose
        None .context STZ

    &Libraries
        Libraries .context STZ
    JMP2r

    &Uxntal
        Uxntal .context STZ
    JMP2r

    &Types
        Types .context STZ
    JMP2r

    &Aliases
        Aliases .context STZ
    JMP2r

    &Constants
        Constants .context STZ
    JMP2r

    &ProgramState
        ProgramState .context STZ
    JMP2r

    &Devices
        Devices .context STZ
    JMP2r

    &Functions
        Functions .context STZ
    JMP2r

    &Main
        Main .context STZ
    JMP2r



@updateState
    .c STZ ( take char from the stack and put it in c )
    .state LDZ StringConst EQU 
    .c LDZ #22 EQU ( " has an ASCII code value of 34 )
    AND
    ,&EndString JCN

    .state LDZ StringConst EQU
    .c LDZ #22 NEQ
    AND
    ,&String JCN
    JMP2r

    .c STZ ( take char from the stack and put it in c )
    .state LDZ CharConst EQU 
    .c LDZ #27 EQU ( " has an ASCII code value of 34 )
    AND
    ,&EndChar JCN

    .state LDZ CharConst EQU
    .c LDZ #27 NEQ
    AND
    ,&Char JCN
    JMP2r

    .state LDZ Comment EQU
    .c LDZ #0a EQU
    AND
    ,&Base JCN
    JMP2r

    .state LDZ StringConst NEQ
    .state LDZ CharConst NEQ
    AND
    .state LDZ Comment NEQ
    AND
    ,&second_jump JCN ( state /= StringConst .and. state /= CharConst .and. state /= Comment )

    ,&nextState_state JMP ( else nextState = state )
    JMP2r

    &nextState_state
        .state LDZ .nextState STZ
    JMP2r

    &EndString
        EndStringConst .nextState STZ
    JMP2r

    &String
        StringConst .nextState STZ
    JMP2r

    &EndChar
        EndCharConst .nextState STZ
    JMP2r

    &Char
        CharConst .nextState STZ
    JMP2r

    &Base
        Base .nextState STZ
    JMP2r

    &second_jump
        .c LDZ #22 EQU ( " has an ASCII code value of 34 )
        ,&String JCN
        JMP2r
        .c LDZ #27 EQU
        ,&Char JCN
        JMP2r

        .state LDZ Minus EQU
        .c LDZ LIT "- EQU
        AND
        ,&Comment JCN
        JMP2r

        .state LDZ Comment EQU
        .c LDZ #0a EQU
        AND
        ,&Base JCN
        JMP2r

        .c LDZ LIT "{ EQU 
        ,&BlockOpen JCN
        JMP2r
        .c LDZ LIT "} EQU 
        ,&BlockClose JCN
        JMP2r

        .c LDZ LIT "( EQU 
        ,&ParenOpen JCN
        JMP2r
        .c LDZ LIT ") EQU 
        ,&ParenClose JCN
        JMP2r

        .c LDZ LIT "[ EQU 
        ,&BracketOpen JCN
        JMP2r
        .c LDZ LIT "] EQU 
        ,&BracketClose JCN
        JMP2r

        .c LDZ LIT "\ EQU 
        ,&BindOpen JCN
        JMP2r

        .c LDZ LIT "= EQU 
        ,&Operator2_Assignment JCN
        JMP2r

        .c LDZ LIT "` EQU 
        ,&Quote JCN
        JMP2r

         
        ,&isIdentifierState JSR2
        ,&isEndConstState JSR2
        ORA
        .state LDZ BlockOpen EQU
        .state LDZ BracketOpen EQU
        ORA
        .state LDZ ParenOpen EQU
        ORA ORA
        .c LDZ LIT "  EQU
        .c LDZ #09 EQU
        ORA
        AND
        ,&Separator JCN
        JMP2r


        .c LDZ LIT ", EQU 
        ,&Comma JCN
        JMP2r

        .c LDZ LIT ": EQU 
        ,&TypeDeclarator JCN
        JMP2r

        .c LDZ LIT "| EQU 
        ,&AltSeparator JCN
        JMP2r

        .state LDZ NumConst NEQ
        .c LDZ LIT ". EQU
        AND
        ,&BindClose JCN
        JMP2r

        .state LDZ NumConst EQU
        .c LDZ LIT "_ EQU
        AND
        ,&NumConst JCN
        JMP2r

        ,&isIdentifierState JSR2
        EOR
        ;isIdentifierStartChar JSR2
        AND
        ,&Identifier JCN
        JMP2r 

        ,&isIdentifierState JSR2
        EOR
        ;isTypeIdentifierStartChar JSR2
        AND
        ,&TypeIdentifier JCN
        JMP2r

        ,&isIdentifierState JSR2
        EOR
        ,&isStringConstState JSR2
        ORA
        ,&TypeIdentifier JCN
        JMP2r

        ,&isIdentifierState JSR2
        ,&isStringConstState JSR2
        ORA EOR
        ,&isdigit JSR2
        AND
        ,&NumConst JCN
        JMP2r

        .state LDZ LeftPointy EQU
        .c LDZ LIT "- EQU
        AND
        ,&TypeSeparator JCN
        JMP2r

        .state LDZ Minus NEQ
        .c LDZ LIT "- EQU
        AND
        ,&Minus JCN
        JMP2r

        .c LDZ LIT "  EQU
        .c LDZ #09 EQU
        ORA
        .state LDZ Minus EQU
        AND
        ,&Operator2 JCN
        JMP2r

        .state LDZ Operator NEQ
        .state LDZ Operator2 NEQ
        AND
        .state LDZ LeftPointy NEQ
        .c LDZ LIT "< EQU
        AND AND
        ,&LeftPointy JCN
        JMP2r

        .state LDZ Operator NEQ
        .state LDZ Operator2 NEQ
        AND
        .state LDZ LeftPointy NEQ
        ;isOperator JSR2
        AND AND
        ,&Operator JCN
        JMP2r

        .state LDZ Operator EQU
        .state LDZ LeftPointy EQU
        ORA
        .state LDZ Assignment EQU
        ORA
        ;isOperator JSR2
        AND
        ,&TypeSeparator_Operator2 JCN
        JMP2r


        .state LDZ Operator2 EQU
        ,&Base JCN
        JMP2r

        .state LDZ Operator EQU
        .state LDZ LeftPointy EQU
        ORA
        ;isOperator JSR2
        EOR AND
        ,&Base JCN
        JMP2r

        .state LDZ ExprSeparator NEQ
        ;isExprSeparator JSR2
        AND
        ,&ExprSeparator JCN
        JMP2r

        .c LDZ LIT "  EQU
        .c LDZ #09 EQU
        ORA
        ;isExprSeparator JSR2
        ORA
        .state LDZ ExprSeparator EQU
        AND
        ,&Separator JCN
        ,&nextState_state JMP ( else nextState = state )
        JMP2r



    
    &Comment
        Comment .nextState STZ
    JMP2r

    &BlockOpen
        BlockOpen .nextState STZ
    JMP2r

    &BlockClose
        BlockClose .nextState STZ
    JMP2r

    &ParenOpen
        ParenOpen .nextState STZ
    JMP2r

    &ParenClose
        ParenClose .nextState STZ
    JMP2r

    &BracketOpen
        BracketOpen .nextState STZ
    JMP2r

    &BracketClose
        BracketClose .nextState STZ
    JMP2r

    &BindOpen
        BindOpen .nextState STZ
    JMP2r

    &Operator2_Assignment
        .state LDZ Operator EQU
        .state LDZ LeftPointy EQU
        ORA
        .state LDZ Assignment EQU
        ORA
        ,&Operator2 JCN
        ,&Assignment JMP
    JMP2r

    &TypeSeparator_Operator2
        .state LDZ LeftPointy EQU
        .c LDZ LIT "- EQU
        AND
        ,&TypeSeparator JCN
        ,&Operator2 JMP
    JMP2r

    &isIdentifierState
        .state LDZ Identifier EQU
        .state LDZ TypeIdentifier EQU
        ORA
    JMP2r

    &isEndConstState
        .state LDZ EndCharConst EQU
        .state LDZ EndStringConst EQU
        ORA
        .state LDZ NumConst EQU
        ORA
    JMP2r

    &isStringConstState
        .state LDZ CharConst EQU
        .state LDZ CharConst EQU
        ORA
        
    JMP2r


    &Operator2
        Operator2 .nextState STZ
    JMP2r

    &Assignment
        Assignment .nextState STZ
    JMP2r

    &Quote
        Quote .nextState STZ
    JMP2r

    &Comma
        Comma .nextState STZ
    JMP2r

    &Separator
        Separator .nextState STZ
    JMP2r

    &TypeDeclarator
        TypeDeclarator .nextState STZ
    JMP2r

    &AltSeparator
        AltSeparator .nextState STZ
    JMP2r

    &BindClose
        BindClose .nextState STZ
    JMP2r

    &NumConst
        NumConst .nextState STZ
    JMP2r

    &Identifier
        Identifier .nextState STZ
    JMP2r

    &Minus
        Minus .nextState STZ
    JMP2r

    &LeftPointy
        LeftPointy .nextState STZ
    JMP2r

    &Operator
        Operator .nextState STZ
    JMP2r

    &TypeSeparator
        TypeSeparator .nextState STZ
    JMP2r

    &ExprSeparator
        ExprSeparator .nextState STZ
    JMP2r

    &TypeIdentifier
        TypeIdentifier .nextState STZ
    JMP2r

JMP2r




    



    




